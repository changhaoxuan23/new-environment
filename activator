# to use packages installed here, simply source this file
# to make packages here available for any shell you started later automatically, just run this script
#  do note you still need to start a new shall before these configurations can take effect
# to undo what we have done when you executed this file, you should remove the line that sources this file
#  from your .bashrc file manually. Do not give us any change to *nuke* your bash configurations by mistake.
#  **We will miss you!**
# this will work only if you are using bash
# this file also provides a set of utility functions (commands) named new-environment-*
# use new-environment-[post/read]-news to post or read news
# use new-environment-[post/read]-comment to post or read comments


# setup PATH.
export PATH="__{{export_directory}}__/bin:${PATH}"

# make man pages available
#  in case the original value of $MANPATH is an empty string, there will be a tailing colon in the final value
#  therefore include default man paths
export MANPATH="__{{export_directory}}__/share/man:${MANPATH}"

# setup C and C++ compiler
export CC=clang
export CXX=clang++

# provide access to header files
export CFLAGS="-I__{{export_directory}}__/include ${CFLAGS}"
export CXXFLAGS="-I__{{export_directory}}__/include ${CXXFLAGS}"
export CPATH="__{{export_directory}}__/include:${CPATH}"

# provide access to libraries
export LDFLAGS="-fuse-ld=lld ${LDFLAGS}"
export LIBRARY_PATH="__{{export_directory}}__/lib:${LIBRARY_PATH}"

# add search path for pkg-config
export PKG_CONFIG_PATH="__{{export_directory}}__/lib/pkgconfig/:/usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:${PKG_CONFIG_PATH}"

# add runtime search directory
_new_LD_LIBRARY_PATH='__{{export_directory}}__/lib/x86_64-unknown-linux-gnu:__{{export_directory}}__/lib'
if [ -z "${LD_LIBRARY_PATH}" ];then
  export LD_LIBRARY_PATH="${_new_LD_LIBRARY_PATH}"
else
  export LD_LIBRARY_PATH="${_new_LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}"
fi

# helping functions
new-environment-list-packages(){
  for version_file in "__{{install_directory}}__/"*.version;do
    echo "$(basename "${version_file::-8}"): $(cat "${version_file}")"
  done
}
new-environment-read-news(){
  if [ ! -f "__{{export_directory}}__/.meta/NEWS" ];then
    printf -- 'no news for now\n'
    return
  fi
  less -r "__{{export_directory}}__/.meta/NEWS"
}
new-environment-post-news(){
  vim "__{{export_directory}}__/.meta/NEWS"
}
new-environment-read-comment(){
  less "__{{export_directory}}__/.meta/"*.comment
}
new-environment-post-comment(){
  vim "__{{export_directory}}__/.meta/$(whoami).comment"
}
new-environment-get-export-directory(){
  printf -- '__{{export_directory}}__'
}
new-environment-get-install-directory(){
  printf -- '__{{install_directory}}__'
}
# export these functions to make it available in sub shells
export -f new-environment-get-export-directory
export -f new-environment-get-install-directory


# if this script is invoked directly, append a source command to .bashrc of the user
#  when a script is sourced, the value of $0 is not changed therefore will not point to this script
if [ "$(realpath -- "$0")" = '__{{export_directory}}__/README' ];then
  # add empty line so that we will not break things even if there is no empty line at the end of .bashrc
  echo >> "${HOME}/.bashrc"
  echo 'source __{{export_directory}}__/README' >> "${HOME}/.bashrc"
  printf -- '\x1b[1;32mYou are ready to go now! Welcome!\x1b[0m\n'
  printf -- '\x1b[1;32m Though you still need to restart your shell...\x1b[0m\n'
fi
