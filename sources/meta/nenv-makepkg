#!/bin/env bash
set -e
#  This is the new driver of make files for new-environment meant to provide a more flexible building routine.
#  New make files written after this script is introduced should define functions and variables to be invoked
#   by this script for different stages of building and installing a package
#  Usage: nenv-makepkg <make-file>
#
# All variables and functions previously available to make file after prepare-execution-environment is sources
#  are still available when make file is executed by this driver, while the following variables will are also
#  available to ease coding:
## package_prefix: final destination of the installation, generally speaking the value shall be set as prefix
## source_directory: location of the source
## package_directory: location to which temporary result shall be installed
## package_content_directory: standard prefix to access file in the temporary install destination
### if we have configured PREFIX=/foo and are installing to temporary destination at /bar,
###  this will result to the files being installed into /bar/foo/...
###  the file that will be installed to /foo/bin/a should be found at /bar/foo/bin/a
###  this variable will make accessing files in the temporary destination simpler
#
# You can include other helping functions or override default function if you are careful enough by pointing
#  environment variable NENV_EXTRA_SOURCE to a list of files containing them. This variable is parsed by:
#  if it is empty, do nothing
#  if it is not empty, handle it as if it is an array of paths separated by ':'
#   just like PATH, there is no way to escape the separator therefore it is impossible to include one in path
#  for each element in the list, if it points to a file, source it directly
#   if it points to a directory, source all files under its subtree
#
# The full routine is split into 6 stages following:
#  source , fetch the source code by downloading latest release or cloning/updating the repository
#            check on the version shall also be done here to prevent building the same version multiple times
#           function: nenv_make_source
#           this stage will be skipped if NENV_SKIP_SOURCE is set to any value that is not empty
#
#  prepare, do preparations on the source code before the actual build
#           function: nenv_make_prepare
#           this stage will be skipped if NENV_SKIP_PREPARE is set to any value that is not empty
#
#  build  , actually build the code
#           function: nenv_make_build
#           this stage will be skipped if NENV_SKIP_BUILD is set to any value that is not empty
#
#  check  , check the build result via tests provided alongside the source code
#           function: nenv_make_check
#           this stage will be skipped if NENV_SKIP_CHECK is set to any value that is not empty
#
#  pack   , install the build result into a temporary destination, effectively creating a binary package
#           function: nenv_make_pack
#           this stage will be skipped if NENV_SKIP_PACK is set to any value that is not empty
#
#  install, install the binary package to the final destination
#           function: nenv_make_install
#           this stage will be skipped if NENV_SKIP_INSTALL is set to any value that is not empty
#
#  all these functions shall return 0 on success, 77 for request of exit without error to report, and other
#   non-zero value on error
#  do not terminate executing with exit or similar methods since the driver may have further work to be done
#   even after the build has failed
#
# To allow more flexibility and reduce amount of code that must be duplicated, hooks are introduced.
#  Up to now, we have the following hooks:
#   cleanup, which will run which the driver exists
#
#  All hooks are invoked by invoking each and every element as a function in the array bearing the same name
#   as the hook. The array can be safely omitted.

do_cleanup() {
  for f in "${cleanup[@]}";do
    "$f"
  done
}
trap do_cleanup EXIT

# source helping script at the path saved in $1
#  if it points to a file, source it directly, otherwise source all files within it if it is a directory
_load_helping_script() {
  mapfile -d $'\x00' -t files < <(find "$1" -type f -print0)
  for f in "${files[@]}";do
    . "${f}"
  done
}

# load all helping sources listed in the list, which shall have the same structure like PATH
#  such list shall be stored in $1
_load_helping_script_list() {
  mapfile -d ':' -t sources < <(echo -n "$1")
  for target in "${sources[@]}";do
    _load_helping_script "${target}"
  done
}

# prepare basic variables
scripts_directory='__{{install_directory}}__/scripts'
stow_directory='__{{install_directory}}__'
target_directory='__{{export_directory}}__'
_using_hook=1

# load standard helpers
_load_helping_script_list '__{{install_directory}}__/scripts/helpers'

# load user specified helpers
_load_helping_script_list "${NENV_EXTRA_SOURCE}"

# include the make script
#  since setting up helping variables requires variables set by the make script, we have to do this at the
#   very beginning
#  but this is done after helper functions are set in case the make script will use some of which outside
#   the functions
_make_file="$1"
shift
if [ ! -f "${_make_file}" ];then
  _make_file="__{{install_directory}}__/scripts/${_make_file}"
fi
. "${_make_file}"

# prepare extra helping variables
package_prefix="${stow_directory}/${package}"
source_directory="${stow_directory}/${package}.build"
package_directory="${stow_directory}/${package}.new"
package_content_directory="${stow_directory}/${package}.new${package_prefix}"

check-uninstall "$@"

stages=(
  # syntax: <name>%<function>%<skip-variable>%<start-message>%<success-message>
  'source%nenv_make_source%NENV_SKIP_SOURCE%preparing source...%source ready'
  'prepare%nenv_make_prepare%NENV_SKIP_PREPARE%preparing for build...%ready to build'
  'build%nenv_make_build%NENV_SKIP_BUILD%building...%package built'
  'check%nenv_make_check%NENV_SKIP_CHECK%checking the build...%build checked'
  'pack%nenv_make_pack%NENV_SKIP_PACK%packing...%package packed'
  'install%nenv_make_install%NENV_SKIP_INSTALL%installing...%installed'
)

mkdir --parent "${source_directory}" "${package_directory}"
for stage in "${stages[@]}";do
  mapfile -t -d '%' specifications < <(echo -n "${stage}")
  name="${specifications[0]}"
  func="${specifications[1]}"
  skipper="${specifications[2]}"
  start_message="${specifications[3]}"
  success_message="${specifications[4]}"
  if [ -z "${!skipper}" ] && [ "$(type -t "${func}" 2>/dev/null)" = 'function' ];then
    log-cyan '==> %s: %s\n' "${name}" "${start_message}"
    "${func}" | true
    return_value=${PIPESTATUS[0]}
    if [ ${return_value} -ne 0 ] && [ ${return_value} -ne 77 ] ;then
      log-red '==> %s returned non-zero value\n' "${func}"
      break
    fi
    if [ ${return_value} -ne 0 ];then
      log-blue '%s: terminate requested, which is not an error\n' "${name}"
      break
    fi
    log-green '==> %s\n' "${success_message}"
  else
    log-cyan '==> %s: skipped' "${name}"
  fi
done