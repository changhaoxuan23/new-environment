#!/bin/bash

# include utilities
source '__{{install_directory}}__/scripts/common/utility'
# utility functions. most of them requires some global variable properly set, make sure you read the comment
#  before using any of which. If you see nothing regards to variable requirement within the comment, possibly
#  that means that at the time this script is sourced, which gives you access to these functions, the variable
#  required by that function must be set or the execution shall terminate, so you do not need to worry
# for the commands executed right at the moment this file is sourced, see the end of this file

# prepare execution environment for scripts that builds softwares
# this file shall be sourced, which requires:
#  function cleanup that cleans when the script terminates
#  variable scripts_directory that points to the directory holding the script
#  variable package, the name of package
# and which sets:
#  variable stow_directory that points to the directory holding individuals softwares
#  variable target_directory that points to the nenv directory

# make the execution terminate whenever an error is triggered
set -e

# ensure all variables required have been set up properly
if ! type -t cleanup > /dev/null 2>&1;then
  printf -- 'cleanup not set!\n'
  exit 1
fi

if [ -z "${scripts_directory}" ];then
  printf -- 'scripts_directory is empty!\n'
  exit 1
fi

if [ -z "${package}" ];then
  printf -- 'package is empty!\n'
  exit 1
fi

# make path absolute
scripts_directory="$(realpath --canonicalize-existing "${scripts_directory}")"

# setup stow_directory
stow_directory="$(realpath --canonicalize-existing "${scripts_directory}/..")"

# hardcoded target directory
target_directory="__{{export_directory}}__"

# ensure cleanup afterwards so that we will not nuke files by mistake
trap cleanup EXIT

# do common things: check if we should do uninstall
check-uninstall "$@"