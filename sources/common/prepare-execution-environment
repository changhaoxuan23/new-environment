#!/bin/bash

# utility functions. most of them requires some global variable properly set, make sure you read the comment
#  before using any of which. If you see nothing regards to variable requirement within the comment, possibly
#  that means that at the time this script is sourced, which gives you access to these functions, the variable
#  required by that function must be set or the execution shall terminate, so you do not need to worry
# for the commands executed right at the moment this file is sourced, see the end of this file

# output helpers
# make output colorful, all functions in this class requires no global variable
declare -A _execution_environment_color_mapping=(
  [red]='\x1b[1;31m'
  [green]='\x1b[1;32m'
  [yellow]='\x1b[1;33m'
  [blue]='\x1b[1;34m'
  [magenta]='\x1b[1;35m'
  [cyan]='\x1b[1;36m'
  [white]='\x1b[1;37m'
)
for color in "${!_execution_environment_color_mapping[@]}";do
  eval "log-${color}(){ printf -- '${_execution_environment_color_mapping[${color}]}'; printf -- \$@; printf -- '\x1b[0m'; }"
done

# retry remove until we success, use this to replace rm -rf
#  we need this since it seems like that NFS may create some internal file entry which fails rm -rf calls
stable-remove-directory(){
  while ! rm -rf "$@";do
    sleep 2
  done
}

is-python-package(){
  if [ "${package::7}" = 'python-' ];then return 0;fi
  return 1
}

# check bypass configuration before actual version check
meta-version-check(){
  printf -- 'building %s: %s\n' "${package}" "${new_version}"
  if [ -n "${SKIP_VERSION_CHECK}" ];then return 0;fi
  if [ ! -f "${stow_directory}/${package}.version" ];then return 0;fi
  return 1
}

# format semantic version code into integers with semantical order preserved
format-semantic-version(){
  local splited_code
  mapfile -d '.' -t splited_code < <(echo -n "$1")
  printf -- '%d' "$((splited_code[0]*1000000+splited_code[1]*1000+splited_code[2]))"
}

# build git version
#  current working directory should be in the git work tree
build-git-version(){
  new_version="$( set -o pipefail
    git describe --long --abbrev=7 --tags 2>/dev/null | sed -e 's/\([^-]*-g\)/r\1/;s/-/./g' -E -e 's/^[^0-9]*(.+)$/\1/' ||
    printf "r%s.%s" "$(git rev-list --count HEAD)" "$(git rev-parse --short=7 HEAD)"
  )"
}

# check semantic version code x.y.z, return 0 if to be proceeded
#  uses: new_version and package
#  old version is automatically read from version file if exists
check-semantic-version(){
  if meta-version-check;then return 0;fi
  local old_version
  local formatted_new_version
  old_version="$(cat "${stow_directory}/${package}.version")"
  old_version="$(format-semantic-version "${old_version}")"
  formatted_new_version="$(format-semantic-version "${new_version}")"
  if [ "${formatted_new_version}" -le "${old_version}" ];then
    printf -- '%s: already up to date\n' "${package}"
    return 1
  fi
  return 0
}

# check git version, return 0 if to be proceeded
#  uses: new_version and package
check-git-version(){
  if meta-version-check;then return 0;fi
  local old_version
  old_version="$(cat "${stow_directory}/${package}.version")"
  if [ "${new_version}" = "${old_version}" ];then
    printf -- '%s: already up to date\n' "${package}"
    return 1
  fi
  return 0
}

# remove old package if exists
#  uses: variable package, the name of package
remove-old-package(){
  if [ -f "${stow_directory}/${package}.version" ];then
    stow --dir="${stow_directory}" --target="${target_directory}" --delete "${package}"
    if is-python-package;then
      stow --dir="${stow_directory}" --target="${stow_directory}/python" --delete "${package}"
    fi
    stable-remove-directory "${stow_directory}/${package}"
    rm -f "${stow_directory}/${package}.version"
  fi
}

# install new package to publicly visible destination
#  uses: variable package, the name of package
#        variable version, the new version string to save
install-new-package(){
  stow --dir="${stow_directory}" --target="${target_directory}" --stow "${package}"
  if is-python-package;then
    stow --dir="${stow_directory}" --target="${stow_directory}/python" --stow "${package}"
  fi
  printf '%s: installed %s\n' "${package}" "${version}"
  printf '%s' "${version}" > "${stow_directory}/${package}.version"
}

# check and uninstall if required
#  if this function is called directly, you will need to pass all parameters with "$@"
check-uninstall(){
  if [ $# -lt 1 ];then return;fi
  if [ "$1" = 'uninstall' ];then
    remove-old-package
    exit
  fi
}

# prepare source from a git repository
# positional argument: the url to remote repository
#                      (optional) the branch/tag to check out
# after this function returns, current working directory shall be in the working tree
prepare-git-source(){
  if [ ! -d "${stow_directory}/${package}.build" ];then
    while ! git clone "$1" "${stow_directory}/${package}.build";do sleep 1;done
  fi
  cd "${stow_directory}/${package}.build"
  if [ $# -eq 2 ];then
    git checkout "$2"
  fi
  while ! git pull --rebase;do sleep 1;done
}

# perform a full procedure of regular installation:
#  remove the old package (if which exists) via remove-old-package
#  copy newly installed copy to the final position
#  install it via install-new-package
# note that this requires the newly installed copy is installed by
#  make DESTDIR="${stow_directory}/${package}.new" install
# or something similar, otherwise you will need to install it manually
# uses:
#   variable version, the new version string to save
full-install(){
  remove-old-package
  mv "${stow_directory}/${package}.new${stow_directory}/${package}" "${stow_directory}/${package}"
  install-new-package
}


# prepare execution environment for scripts that builds softwares
# this file shall be sourced, which requires:
#  function cleanup that cleans when the script terminates
#  variable scripts_directory that points to the directory holding the script
#  variable package, the name of package
# and which sets:
#  variable stow_directory that points to the directory holding individuals softwares
#  variable target_directory that points to the nenv directory

# make the execution terminate whenever an error is triggered
set -e

# ensure all variables required have been set up properly
if ! type -t cleanup > /dev/null 2>&1;then
  printf -- 'cleanup not set!\n'
  exit 1
fi

if [ -z "${scripts_directory}" ];then
  printf -- 'scripts_directory is empty!\n'
  exit 1
fi

if [ -z "${package}" ];then
  printf -- 'package is empty!\n'
  exit 1
fi

# make path absolute
scripts_directory="$(realpath --canonicalize-existing "${scripts_directory}")"

# setup stow_directory
stow_directory="$(realpath --canonicalize-existing "${scripts_directory}/..")"

# hardcoded target directory
target_directory="__{{export_directory}}__"

# ensure cleanup afterwards so that we will not nuke files by mistake
trap cleanup EXIT

# do common things: check if we should do uninstall
check-uninstall "$@"